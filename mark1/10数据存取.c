#define _CRT_SECURE_NO_WARNINGS 1

#include<stdio.h>
//大端存取：高位地址存低位数据，低位地址存放高位数据
//小端存取：低位地址存低们数据，高们地址存高位数据

//int check_sys()
//{
//	int a = 0x00000114;
//	char* p = (char*)&a;
//	int b = *p;
//	if (b == 20)
//	{
//		return 0;
//	}
//	else if (b==0)
//	{
//		return 1;
//	}
//}

//int check_sys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//指针类型决定了指针解引用操作符能访问几个字节  char* p是一个字节，int* p是4个字节，p+1  这里的1表示一个此类型数据字节长度
// 
// 
//int main()
//{
//	//写一段代码实现当前机器字节序是大端还是小端
//	//返回1为大端
//	//返回0为小端
//	int ret=check_sys();
//	if (ret == 0)
//	{
//		printf("机器为大端存取。\n");
//	}
//	else if (ret ==1)
//	{
//		printf("机器为小端存取。\n");
//	}
//	return 0;
//}



//了解数据存取顺序
//int main()
//{
//	int a = 0x11223344;
//	char* p = (char*) & a;
//	int i = 0;
//	printf("%d", a);
//	for (i = 0; i < 4; i++)
//	{
//		printf("%x ", *(p + i));
//	}
//	return 0;
//}


//取数
//int main()
//{
//	//char a = 0x11223314;
//	char a = -1;
//	//10000000000000000000000000000001		原
//	//11111111111111111111111111111110		反
//	//11111111111111111111111111111111		补
//	//11111111  a中只能存一个字节
//	//打印时有符号位需要整型提升补符号位
//	//11111111111111111111111111111111
//	signed char b = -1;
//	//11111111  b中只能存一个字节
//	//11111111111111111111111111111111
//	//打印时有符号位需要整型提升补符号位
//	unsigned char c = -1;
//	//11111111	c中只能存一个字节
//	//00000000000000000000000011111111
//	//无符号整型提升补0
//	printf("a=%d  b=%d  c=%d", a, b, c);	//%d是32位，四个字节，而字符只有一个字节，所以需要整型提升。
//	return 0;
//}

//int main()
//{
//	char a = -128;
//	//10000000000000000000000010000000		原
//	//11111111111111111111111101111111		反
//	//11111111111111111111111110000000		补
//	//10000000    a中存放
//	//11111111111111111111111110000000
//	printf("%u\n", a);
//	//%d - 打印十进制的有符号数字
//	//%u - 打印十进制的无符号数字
//	return 0;
//}

//int main()
//{
//	char a = 127;
//	char b = 128;		//-128   一个字节的有符号位是127到-128之间（0.1，2....127.-128.-127...-1）形成一个圆，无符号位是0-255之间
//	printf("%d", b);
//	return 0;
//}

//int main()
//{
//	int i = -20;
//	unsigned int j = 10;
//	printf("%d\n", i + j);
//	return 0;
//}
//
////10000000000000000000000000010100		原-20
////11111111111111111111111111101011		反
////11111111111111111111111111101100		补码
////00000000000000000000000000001010		补码
////11111111111111111111111111110110		结果
////11111111111111111111111111110101		反
////10000000000000000000000000001010		原-10

//int main()
//{
//	unsigned int i;
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	return 0;
//}

//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;
//	}
//	printf("%d", strlen(a));		//-1,-2....-128,127,126...3,2,1,0     长度为255，因为'\0'和0结束。
//	return 0;
//}

//unsigned char i = 0;
//int main()
//{
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hello world\n");		//死循环，因为无符号最大值255，i的值不会超过255，又变为了0
//	}
//	return 0;
//}

//int main()
//{
//	double a=1E10;   //科学记数法
//	printf("%lf", a);
//	return 0;
//}

//char   -128  127    unsigned  0-255
//

int main()
{
	int n = 9;
	//00000000000000000000000000001001	补码
	//0 00000000 00000000000000000001001
	//S    E         M
	float* pf = (float*)&n;
	printf("%d\n", n);
	printf("%f\n", *pf);
	*pf = 9.0;
	//(-1)**0*1.001**2**3
	//S=0,E=130,M=1.001
	//SEM 01000001 00010000 00000000 00000000
	printf("%d\n", n);  //以浮点型存，以整数取，所以非常大了。
	printf("%f\n", *pf);
}

//浮点数的存取方法：
//(-1)**S*M*2**E
//(-1)**S表示符号位，当S=0时V为正数，当S=1时，V为负数
//M表示有效数字，大于等于1，小于2.
//2**E表示指数位
//如5.0   二进制为101.0，相当 于  (-1)**0*1.01*2**2   即S=0,M=1.01,E=2
//如9.0   二进制为1001.0，相当于(-1)**0*1.001*2**3	  即S=0，M=1.001，E=3
//IEEE 754规定：  32位 S:1bit   E:8bit   M:23bit		64位  S:1bit   E:11bit   M:52bit
//S直接存0和1，E存E+127的二进制数，M不存小数点前面的1，只存小数点后面的数

//int main()
//{
//	float f = 5.5;
//	//5.5
//	//101.1
//	//(-1)**0*1.011*2**2
//	//S=0,M=1.011,E=2
//	//S:0,M:011,E:129
//	//存SEM:0 100 0000 1 011 0000 0000 0000 0000 0000
//	//16进制：40b00000
//	return 0;
//}

//E不为全0或全1   E-127为真实值    M前补1，
//E为全0          1.xxxx*2**-127,无限接近0，E=1-127   就是说E直接用-127即可，不用算了。
//E为全1          1.xxxx*2**128,无限大，不讨论。